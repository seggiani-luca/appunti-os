\documentclass[a4paper,11pt]{article}
\usepackage[a4paper, margin=8em]{geometry}

% usa i pacchetti per la scrittura in italiano
\usepackage[french,italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\frenchspacing 

% usa i pacchetti per la formattazione matematica
\usepackage{amsmath, amssymb, amsthm, amsfonts}

% usa altri pacchetti
\usepackage{gensymb}
\usepackage{hyperref}
\usepackage{standalone}

\usepackage{colortbl}

\usepackage{xstring}
\usepackage{karnaugh-map}

% imposta il titolo
\title{Appunti Sistemi Operativi}
\author{Luca Seggiani}
\date{2025}

% imposta lo stile
% usa helvetica
\usepackage[scaled]{helvet}
% usa palatino
\usepackage{palatino}
% usa un font monospazio guardabile
\usepackage{lmodern}

\renewcommand{\rmdefault}{ppl}
\renewcommand{\sfdefault}{phv}
\renewcommand{\ttdefault}{lmtt}

% circuiti
\usepackage{circuitikz}
\usetikzlibrary{babel}

% testo cerchiato
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}

% disponi il titolo
\makeatletter
\renewcommand{\maketitle} {
	\begin{center} 
		\begin{minipage}[t]{.8\textwidth}
			\textsf{\huge\bfseries \@title} 
		\end{minipage}%
		\begin{minipage}[t]{.2\textwidth}
			\raggedleft \vspace{-1.65em}
			\textsf{\small \@author} \vfill
			\textsf{\small \@date}
		\end{minipage}
		\par
	\end{center}

	\thispagestyle{empty}
	\pagestyle{fancy}
}
\makeatother

% disponi teoremi
\usepackage{tcolorbox}
\newtcolorbox[auto counter, number within=section]{theorem}[2][]{%
	colback=blue!10, 
	colframe=blue!40!black, 
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries, 
	title=Teorema~\thetcbcounter: #2, 
	#1
}

% disponi definizioni
\newtcolorbox[auto counter, number within=section]{definition}[2][]{%
	colback=red!10,
	colframe=red!40!black,
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries,
	title=Definizione~\thetcbcounter: #2,
	#1
}

% disponi codice
\usepackage{listings}
\usepackage[table]{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{codestyle}{
		backgroundcolor=\color{black!5}, 
		commentstyle=\color{codegreen},
		keywordstyle=\bfseries\color{magenta},
		numberstyle=\sffamily\tiny\color{black!60},
		stringstyle=\color{green!50!black},
		basicstyle=\ttfamily\footnotesize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=left,                    
		numbersep=5pt,                  
		showspaces=false,                
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2
}

\lstdefinestyle{shellstyle}{
		backgroundcolor=\color{black!5}, 
		basicstyle=\ttfamily\footnotesize\color{black}, 
		commentstyle=\color{black}, 
		keywordstyle=\color{black},
		numberstyle=\color{black!5},
		stringstyle=\color{black}, 
		showspaces=false,
		showstringspaces=false, 
		showtabs=false, 
		tabsize=2, 
		numbers=none, 
		breaklines=true
}


\lstdefinelanguage{assembler}{ 
  keywords={AAA, AAD, AAM, AAS, ADC, ADCB, ADCW, ADCL, ADD, ADDB, ADDW, ADDL, AND, ANDB, ANDW, ANDL,
        ARPL, BOUND, BSF, BSFL, BSFW, BSR, BSRL, BSRW, BSWAP, BT, BTC, BTCB, BTCW, BTCL, BTR, 
        BTRB, BTRW, BTRL, BTS, BTSB, BTSW, BTSL, CALL, CBW, CDQ, CLC, CLD, CLI, CLTS, CMC, CMP,
        CMPB, CMPW, CMPL, CMPS, CMPSB, CMPSD, CMPSW, CMPXCHG, CMPXCHGB, CMPXCHGW, CMPXCHGL,
        CMPXCHG8B, CPUID, CWDE, DAA, DAS, DEC, DECB, DECW, DECL, DIV, DIVB, DIVW, DIVL, ENTER,
        HLT, IDIV, IDIVB, IDIVW, IDIVL, IMUL, IMULB, IMULW, IMULL, IN, INB, INW, INL, INC, INCB,
        INCW, INCL, INS, INSB, INSD, INSW, INT, INT3, INTO, INVD, INVLPG, IRET, IRETD, JA, JAE,
        JB, JBE, JC, JCXZ, JE, JECXZ, JG, JGE, JL, JLE, JMP, JNA, JNAE, JNB, JNBE, JNC, JNE, JNG,
        JNGE, JNL, JNLE, JNO, JNP, JNS, JNZ, JO, JP, JPE, JPO, JS, JZ, LAHF, LAR, LCALL, LDS,
        LEA, LEAVE, LES, LFS, LGDT, LGS, LIDT, LMSW, LOCK, LODSB, LODSD, LODSW, LOOP, LOOPE,
        LOOPNE, LSL, LSS, LTR, MOV, MOVB, MOVW, MOVL, MOVSB, MOVSD, MOVSW, MOVSX, MOVSXB,
        MOVSXW, MOVSXL, MOVZX, MOVZXB, MOVZXW, MOVZXL, MUL, MULB, MULW, MULL, NEG, NEGB, NEGW,
        NEGL, NOP, NOT, NOTB, NOTW, NOTL, OR, ORB, ORW, ORL, OUT, OUTB, OUTW, OUTL, OUTSB, OUTSD,
        OUTSW, POP, POPL, POPW, POPB, POPA, POPAD, POPF, POPFD, PUSH, PUSHL, PUSHW, PUSHB, PUSHA, 
				PUSHAD, PUSHF, PUSHFD, RCL, RCLB, RCLW, MOVSL, MOVSB, MOVSW, STOSL, STOSB, STOSW, LODSB, LODSW,
				LODSL, INSB, INSW, INSL, OUTSB, OUTSL, OUTSW
        RCLL, RCR, RCRB, RCRW, RCRL, RDMSR, RDPMC, RDTSC, REP, REPE, REPNE, RET, ROL, ROLB, ROLW,
        ROLL, ROR, RORB, RORW, RORL, SAHF, SAL, SALB, SALW, SALL, SAR, SARB, SARW, SARL, SBB,
        SBBB, SBBW, SBBL, SCASB, SCASD, SCASW, SETA, SETAE, SETB, SETBE, SETC, SETE, SETG, SETGE,
        SETL, SETLE, SETNA, SETNAE, SETNB, SETNBE, SETNC, SETNE, SETNG, SETNGE, SETNL, SETNLE,
        SETNO, SETNP, SETNS, SETNZ, SETO, SETP, SETPE, SETPO, SETS, SETZ, SGDT, SHL, SHLB, SHLW,
        SHLL, SHLD, SHR, SHRB, SHRW, SHRL, SHRD, SIDT, SLDT, SMSW, STC, STD, STI, STOSB, STOSD,
        STOSW, STR, SUB, SUBB, SUBW, SUBL, TEST, TESTB, TESTW, TESTL, VERR, VERW, WAIT, WBINVD,
        XADD, XADDB, XADDW, XADDL, XCHG, XCHGB, XCHGW, XCHGL, XLAT, XLATB, XOR, XORB, XORW, XORL},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{language=assembler, style=codestyle}

% disponi sezioni
\usepackage{titlesec}

\titleformat{\section}
	{\sffamily\Large\bfseries} 
	{\thesection}{1em}{} 
\titleformat{\subsection}
	{\sffamily\large\bfseries}   
	{\thesubsection}{1em}{} 
\titleformat{\subsubsection}
	{\sffamily\normalsize\bfseries} 
	{\thesubsubsection}{1em}{}

% tikz
\usepackage{tikz}

% float
\usepackage{float}

% grafici
\usepackage{pgfplots}
\pgfplotsset{width=10cm,compat=1.9}

% disponi alberi
\usepackage{forest}

\forestset{
	rectstyle/.style={
		for tree={rectangle,draw,font=\large\sffamily}
	},
	roundstyle/.style={
		for tree={circle,draw,font=\large}
	}
}

% disponi algoritmi
\usepackage{algorithm}
\usepackage{algorithmic}
\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\makeatother

% disponi numeri di pagina
\usepackage{fancyhdr}
\fancyhf{} 
\fancyfoot[L]{\sffamily{\thepage}}

\makeatletter
\fancyhead[L]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@title \ \@date}}} 
\fancyhead[R]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@author}}}
\makeatother

\begin{document}
% sezione (data)
\section{Lezione del 22-10-25}

% stili pagina
\thispagestyle{empty}
\pagestyle{fancy}

% testo
\subsection{Mutua esclusione}
Analizziamo il problema della \textbf{mutua esclusione} studiando il seguente pseudocodice C, implementante una semplice struttura \textit{stack}:
\begin{lstlisting}[language=C++, style=codestyle]	
T stack[n];
int top = -1;

// inserisci in cima
void insert(T y) {
	top++;
	stack[top] = y;
}

// estrai dalla cima
T extract() {
	T temp = stack[top];
	top--;
	return temp;
}
\end{lstlisting}

Se le variabili \lstinline|stack| e \lstinline|top| si trovano in memoria condivisa, o in altre la struttura stack creata si trova in memoria condivisa, potremmo incorrere in situazioni dove più operazioni sullo stack vengono iniziate contemporaneamente (le funzioni che operano sullo stack vengono chiamate contemporaneamente), e lo scheduler interlaccia le operazioni in un modo che rende lo stack inconsistente.

Ad esempio, con 2 processi $p_1$ e $p_2$, il primo chiamante \lstinline|insert()| e il secondo chiamante \lstinline|extract()| potremmo avere la timeline di esecuzione:
\begin{lstlisting}[language=C++, style=codestyle]	
t0: top++; 						 // p1
t1: temp = stack[top]; // p2
t2: top--; 						 // p2
t3: stack[top] = y; 	 // p1
\end{lstlisting}
con conseguenze chiaramente disastrose! Si estre da una zona della pila non allocata e si inserisce sovrascrivendo la cima.

Chiaramente, sappiamo che nella maggior parte dei sistemi reali le istruzioni \lstinline|top++|, ecc... non saranno eseguite atomicamente, ma lo saranno le istruzioni assembler che implementano tali istruzioni di alto livello. In ogni caso, se il sistema può fallire visto dal livello alto, possiamo essere sicuri che fallirà anche più probabilmente al livello più basso.

\par\smallskip

Siamo quindi di fronte al classico problema della mutua esclusione, dove vogliamo limitare l'accesso ad una determinata risorsa ad un solo processo per volta, o equivalentemente vogliamo rendere \textit{atomiche} le operazioni su tale risorsa.

\subsubsection{Soluzione (scorretta) software}
Una prima idea potrebbe essere, \textit{in software}, di introdurre un prologo alle funzioni che dovranno essere atomiche. Tale prologo avrà il compito di controllare un determinato flag di \textit{"prenotazione"} sulla risorsa, ad esempio come:
\begin{lstlisting}[language=C++, style=codestyle]	
prologo: 
	while(occupato == 1);
	occupato = 1;
	// sezione critica
epilogo: 
	occupato = 0;
\end{lstlisting}

Dobbiamo però renderci conto che a questo punto i due processi si trovano a condividere una nuova variabile in memoria condivisa, cioè il flag \lstinline|occupato| stesso.
Questo significa che possiamo incorrere nuovamente in situazioni dove lo stato diventa inconsistente, ad esempio, assumendo \lstinline|occupato| inizialmente uguale a 0:
\begin{lstlisting}[language=C++, style=codestyle]	
t0: while(occupato == 1); // p1, passa
t1: while(occupato == 1); // p2, passa
t2: occupato = 1					// p2
t3: occupato = 1					// p1
// p1 e p2 sono entrambi in sezione critica!
\end{lstlisting}

Notiamo inoltre che quello che abbiamo implementato è effettivamente una \textit{busy wait} (attesa attiva) sulla variabile occupato, che nella programmazione di sistemi operativi è inaccettabile (rappresenta overhead inutile che potrebbe essere dedicato ad altri processi).

\subsubsection{Soluzione hardware}
Prevediamo allora una modifica \textit{hardware} che ci permetta di risolvere il problema: magari una nuova istruzione assembler detta \textit{test-and-set} (con mnemonica \lstinline|TSL|).
La \lstinline|TSL| accetterà un registro e un indirizzo in memoria, e il suo funzionamento sarà il seguente:
\begin{itemize}
	\item Carica il valore all'indirizzo nel registro;
	\item Imposta il valore nell'indirizzo a 1.
\end{itemize}

Immaginiamo che realizzare questo tipo di istruzione in sistemi multiprocessore richiederà l'aggiunta al bus di una nuova linea, detta \textit{lock}, che permette ad un processore di bloccare il bus finché non ha terminato la sua operazione.

Quello che potremo fare è quindi implementare 2 routine assembler:
\begin{lstlisting}	
lock(x):
	TSL registro, x
	CMP registro, 0
	JNE lock
	RET // torna al chiamante, entra in sezione critica

unlock(x):
	MOVE x, 0
	RET
\end{lstlisting}

Il fatto che la \lstinline|TSL| imposta subito, e sopratutto atomicamente, il valore all'indirizzo \lstinline|x| a 1, cioè blocca subito la risorsa, ci permette di stare sicuri che nessun'altro avrà l'opportunità di \textit{"rubare"} la risorsa occupata.
Anche schedulando a livello istruzioni assembler (che è ciò che si fà nella realta), dopo la \lstinline|TSL| lo stato del sistema è consistente: il processo che ha diritto alla risorsa vi accederà, gli altri no.

I vantaggi di questo approccio sono che funziona, e funziona anche su sistemi multiprocessoe (assunta memoria condivisa e bus dotato di linea lock).
Gli svantaggi sono che siamo comunque costretti a fare una busy wait, anche se questa è più tollerabile della precedente (la combinazione \lstinline|TSL|, \lstinline|CMP| e \lstinline|JNE| si sbriga in pochi cicli di clock).

In questo caso, prologo ed epilogo visti da un linguaggio di alto livello come il C avranno il seguente aspetto:
\begin{lstlisting}[language=C++, style=codestyle]	
prologo: 
	lock(x)
	// sezione critica
epilogo:
	unlock(x)
\end{lstlisting}

\subsection{Semafori}
I semafori rappresentano strumenti generali per la soluzione di problemi di sincronizzazione.

Un semaforo \lstinline|s| è un oggetto alla quale è associato un intero non negativo, \lstinline|s.value|, con valore iniziale $s_0 \geq 0$.
Al semaforo è associata una lista di attesa, \lstinline|s.queue|, nella quale sono posti i descrittori dei processi che attendono l'autorizzazione a procedere.

Le primitive sul semaforo coinvolgono il contatore \lstinline|s.value|, e sono 2:
\begin{itemize}
	\item \lstinline|wait(s)|: questa si occupa di decrementare, se $> 0$, \lstinline|s.value|. Altrimenti mette il chiamante in attesa. In pseudocodice:
\begin{lstlisting}[language=C++, style=codestyle]	
void wait(s) {
	if(s.value == 0) {
		// metti il chiamante in attesa
		insert(s.queue, /* chiamante */);	
	} else {
		s.value--;
	}
}
\end{lstlisting}
	
	\item \lstinline|signal(s)|: questa si occupa di incrementare \lstinline|s.value|, e se c'erano processi in attesa risvegliarne uno. In pseudocodice:
\begin{lstlisting}[language=C++, style=codestyle]	
void signal(s) {
	if(!isEmpty(s.queue)) {
		primo = extract(s.queue); // e' una coda fifo
		// inserici primo in coda pronti
	} else {
		s.value++;
	}
}
\end{lstlisting}
\end{itemize}

\subsubsection{Semafori di mutua esclusione}
I semafori permettono di realizzare la mutua esclusione. Chiamiamo questo tipo di semafori \textbf{mutex}.

Per realizzare un mutex basta inizializzare un semaforo col valore $s_0 = 1$.
In questo caso basterà inserire prologo ed epilogo nelle funzioni che vogliamo rendere atomiche:
\begin{lstlisting}[language=C++, style=codestyle]	
prologo:
	wait(mutex);
	// sezione critica
epilogo:
	signal(mutex);
\end{lstlisting}

Quello che succede è che alla prima \lstinline|wait()| il semaforo si svuota e tutti i processi successivi dovranno aspettare nella coda \lstinline|mutex.queue|.
Quando il processo finisce la sua operazione, esegue la \lstinline|signal()|, liberando la risorsa per il prossimo processo in attesa. 

\end{document}
